### 3086.Minimum-Moves-to-Pick-K-Ones

如果不考虑第一种操作，仅考虑第二种操作，那么题意就是说找一个位置，然后将临近的k个1移动到该位置，求最少的移动数。显然，我们会将nums里所有是1的index都拿出来放入一个数组arr，那么我们需要在arr里找一个长度为k的滑窗，使得“将它们聚拢至一处”的移动最少：显然我们会将1都聚拢到滑窗里最中间的位置（中位数）。有了以上的结论，我们只需要将滑窗在arr里面走一遍，就能找到某处滑窗位置，使得移动的次数最少。

接下来考虑第一种操作。我们发现它其实“很好用”，我们只需要额外操作两次就可以得到一分：在终点位置旁边的0翻转成1，再将1移动到终点位置。相比于将nums里已有的1“长途搬运”过来，这必然是很合算。所以理论上来说，第一种操作的maxChangs都应该尽量用掉，这样使用第二种操作时，我们只需要将`k-maxChanges`个1聚拢到一处即可。

但是以上的这个结论有几个例外：那就是如果在“终点”位置本身就是1，或者左边/右边有一个1，或者两边都有一个1，那么得到那些1带来的分数所需要的操作，显然会更少。所以实际上，我们使用第一种操作的次数，还可能是`maxChanges-1`，或者`maxChanges-2`，或者是`maxChanges-3`。但是注意，没有其他理由可以更少地使用第一种操作了。

所以，我们将第二种操作写成一个helper函数，那么我们最终的答案就是以下三种中的最小值：
```
maxChanges*2 + helper(k-maxChanges)
(maxChanges-1)*2 + helper(k-maxChanges+1)
(maxChanges-2)*2 + helper(k-maxChanges+2)
(maxChanges-3)*2 + helper(k-maxChanges+3)
```
当然，计算上述表达式的时候，要保证每种操作的数目不能为负数。

至于如何用线性时间来实现helper函数，这类似于`1685.Sum-of-Absolute-Differences-in-a-Sorted-Array`. 假设[0:k-1]里所有元素到其中位数位置的距离之和是s，那么[1:k]里所有元素到其中位数位置的距离之和是：`s + d * (k/2+1) - d * (k - (k/2+1)) - abs(arr[k/2+1]-arr[0]) + abs(arr[k/2+1]-arr[k])```，其中`d=arr[k/2+1]-arr[k/2]`.
```
0 ... k/2 ... k-1
  1 ... k/2+1 ... k     
```
