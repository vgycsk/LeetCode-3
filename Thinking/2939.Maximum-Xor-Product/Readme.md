### 2939.Maximum-Xor-Product

首先考虑XOR只是位操作，bit之间互不影响，所以我们考察一下所有位操作的可能：
```
a:   0, 0, || 1, 1, || 1, 1, || 0, 0
b:   1, 1, || 0, 0, || 1, 1, || 0, 0
x:   0, 1, || 0, 1, || 0, 1, || 0, 1
-----------
a^x: 0, 1, || 1, 0, || 1, 0, || 0, 1
b^x: 1, 0, || 0, 1, || 1, 0, || 0, 1
     G  G     G  G     G  B     B  G
```
为了使得每个bit位上的`(a^x)*(b^x)`最大，我们总结出如下规律：
1. 如果a与b的bit值不同（即一个0一个1），不管如何设置x，都会使得a^x与b^x其中一个是0且令一个是1.
2. 如果a与b的bit值相同，那么最优的x是取与其相反的数值，使得a^x与b^x都是1（因为让两者都是0显然不是最优策略）.

对于第二种情况，决策是固定的。对于第一种情况，我们还需要确定，究竟是让a^x是1，还是让b^x是1. 此时我们发现，无论做何选择，`a^x + b^x`总是固定的。我们知道这样一个定理：在sum固定的情况下，想让两个元素的积最大，我们必然希望这两个元素尽量相等。为了实现这个目标，我们可以在第一次时给`a^x`赋1，之后都给`b^x`赋1，以此实现最大化的`(a^x)*(b^x)`.

但是注意，以上的分析要求x能覆盖a与b的所有bit位。事实上x有限制范围，最多只能设置n个比特位。如果a与b的二进制长度大于x，那么以上分析就不适用了。但是，最优的x应该使得`a^x + b^x`不变这个原则依然是成立的。在这种情况下，如果a已经大于b，那么就在第一种情况时，把0都赋给a^x，把1都赋给b^x，这样可以拉近a^x与b^x，得到最大的乘积。反之，如果a已经小于b，那么在第一种情况时，把1都赋给a^x，把0都赋给b^x。
