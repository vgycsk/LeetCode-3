### 2699.Modify-Graph-Edge-Weights

因为最终修正边权之后的图里要求所有的边都是正数，所以我们第一步肯定先将所有能修改的边从-1改为为最小的正数值1放入图中。

最暴力的思想就是不停地跑Dijkstra求起点到终点的最短距离。如果当前的最短距离已经大于target，那么无解。如果当前的最短距离就是target，那么我们就不需要改动。如果当前的最短距离小于target，且最短距离里不包括任何可修改的边，那么也是无解。剩下的情况就是最短距离小于target，且其中包含了至少一条可修改的边，那么我们可以贪心地将该边权调大，使得路径恰为target。这样我们就消灭了一条小于target的路径。然后重复以上的过程。这样的算法可能会跑o(E)遍的Dijkstra，会TLE。

我们再审视一下我们的Dijkstra算法。注意当我们每次从PQ里弹出一个已经确定最短距离的的点，会尝试通过其邻接的边将一个新点加入PQ，如果我们所用到的所有的边都是不可修改的，那么我们弹出的点及其最短路径也都是不可修改的。但是当我们需要用到一条可修改的边时，比如说已知从起点到a的最短路径，然后a与b有一条可修改的边，此时我们在将b加入PQ时就会有所顾虑。如果“起点到a的最短距离”+“ab之间的边权1”+“b到终点的最短距离”小于target的话，那么我们就违反了题意。所以我们可以贪心地更改这条可修改边，使得三段距离之和变成target。这就意味着我们需要提前计算“b到终点的最短距离”。这样，当b收录进入PQ的时候，我们就保证了这条到达b的路径，不会造成任何“起点到终点的最短路径小于target”，我们可以放心地加入PQ共后续使用。

所以依据上面的算法，可以在一次的Dijkstra的过程中不断地贪心地设置可修改边的边权。知道我们发现终点从PQ里弹出时，意味着我们已经确定了起点到终点的最短距离。如果这个距离不为target，那么就是无解。

===========

Q: 当边P-Q为可编辑边时，则需考虑`dist[S-P]  + weight(P, Q) + dist1[Q-D] < target`，但为何我们能够笃定dist1[Q-D]未经过任何我们已经修改过的可编辑边呢? 因为如果dist1[Q-D]有经过已修改过的可编辑边，现阶段的dist1[Q-D]其实已经比当时纪录的还大了，那上面的条件式可能会给出错误的判定结果。

A: 假设如你所说，当从优先队列弹出P点时，在Q到D的最短路径有一条已经修改过的可编辑边，假设为AB。既然AB已经修改过，那么AB必然是从起点S到某个点（假设是C）的最短距离（已经早于P点从优先队列里处理过）的一部分。于是即存在这样一条路径S-A-B-C，它是短于S-P的（这是因为Dijkstra算法会会按从小到大输出各个点的最短路径）。OK，既然 S-A-B-C<S-P，那么从S到D的最短距离必然不会通过P（即S-P-Q-A-B-D不会是SD的最短距离），因为有一个更短的S-A-B-D。因此即使修改P-Q的操作有你所说的“问题”，也不影响最终的答案，因为它必然不在S-D的最短路径上。
