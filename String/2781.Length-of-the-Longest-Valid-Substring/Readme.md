### 2781.Length-of-the-Longest-Valid-Substring

注意到forbidden里面的字符串都很短，长度不超过10，我们可以用一个26进制的长度来编码的话，二进制的bit只需要最多50位，故一个64位长整形就能满足。这样，我们在word里走10遍不同长度的固定滑窗，每个滑窗对应一个编码，如果与forbidden里的编码相同，那么就意味着这个滑窗对应一个forbidden里的字符串。这样，我们就可以高效地知道word里所有的forbidden字串的位置。

接下来要做的就是在word里找到一个最长的区间，里面不包括任何完整的forbidden字串。这是一个典型的区间问题。我们考虑这样一个子问题：以i为右端点的区间，其左端点最远可以到哪里能符合条件？我们注意到，任何右边界超过i的forbidden子串都不会影响结果（他们肯定不会被完整包含）。所以我们只需要考虑所有右端点不超过i的forbidden子串，为了不完整包括它们中的任何一个，我们显然会取这些forbidden子串的所有左边界里的最大值j，这样[j+1,i]的区间就会符合条件。

于是我们可以归纳出算法。将所有forbidden子串按照右边界排序。这样我们从左往右扫描位置i时，就可以将顺次将所有右边界不超过i的子串加入集合，并从中更新它们左边界的最大值j。于是[j+1,i]就对应了以i为右端点、且不包括任何完整forbidden子串的最大区间。

同理，如果将所有forbidden子串按照左边界排序，也可以适用同样的算法，只不过从右往左扫一遍。
