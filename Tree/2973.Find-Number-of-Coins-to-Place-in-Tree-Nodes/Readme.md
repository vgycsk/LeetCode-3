### 2973.Find-Number-of-Coins-to-Place-in-Tree-Nodes

本题只需要常规的DFS，对于每个节点，假设它的子树的所有的cost都收集在了temp里并保持有序，那么根据题意，收益其实就是这两者的最大值：
```
max(temp[n-1]*temp[n-2]*temp[n-3], temp[0]*temp[1]*temp[n-1]);
```
这是因为，三元素乘积的最大值，要么是三个最大正数的乘积，要么是两个最小负数和一个最大正数的乘积。对于前者，我们只需要盲目地取最大的三个数即可（如果不存在三个正数，那么它自然也不会是最优解）；对于后者，我们也只需要盲目地取两个最小值和一个最大值即可（如果不存在两个负数，那么它自然也不会是最优解）。

综上，我们最多只用到了temp里的五个元素即可。并且在向上传递时，也只需要最多返回五个元素即可。分别是：
1. 最小值temp[0]，当n>=1
2. 次小值temp[1]，当n>=2
3. 第三大值temp[n-3]，当n>=5时才能保证该元素不与2重复。
4. 第二大值temp[n-2]，当n>=4时才能保证该元素不与2重复。
5. 第一大值temp[n-1]，当n>=3时才能保证该元素不与2重复。
