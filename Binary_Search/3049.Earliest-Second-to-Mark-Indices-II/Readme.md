### 3049.Earliest-Second-to-Mark-Indices-II

首先，容易看出此题的答案具有单调性。时间越长，就越容易有清零的机会，也就越容易实现目标。所以我们在最外层套用二分搜值的框架，将求“最优解”的问题，转化为判定“可行解”的问题。

假设给出T秒的时刻，如何判定是否可行呢？我们发现，“清零”操作的性价比是非常高的，如果对于某个index有机会做“清零”操作，我们必然这样做（除非nums[idx]本身就是零）。如果对于某个index，它在时间序列里出现了多次，我们会在哪个时候去清零呢？相对而言我们尽早清零是最优的选择，因为如果你晚些时候去做清零操作，可能存在一个风险：后续没有足够的机会取做“标记”操作了。由此，我们可以在时间序列changeIndices里面，预处理得到哪些时刻我们是在做“清零”。

至此，我们知道哪些时候做“清零”，其余的时候基本首选就是做“减一”，而唯一的制约因素就是要在最后留有足够“标记”的机会。当然并不是无脑的选最后n秒都做“标记”，因为有些“清零”可能在很靠后的时刻才会发生。怎么制定策略呢？这就需要从后往前去安排。

我们维护一个multiset叫做resets，里面存放那些确定要进行清零操作的nums的数值。当我们从后往前遍历的时候，判定时刻i是否能够进行“清零”，有以下两个条件：1.时刻i本身正是之前已经“计划”进行清零的时刻。2.假设i时刻进行清零的话，要保证在剩余的[i:t]的时间里，进行清零的数量（即multiset里面的元素个数）要小于剩余时间的一半，这样才能保证这些被清零的元素有机会被“标记”。如果不满足条件怎么办呢，这意味着我们不能增加这个清零名额，但是可以“调换”一个清零名额，将resets里面腾出一个来转给当前的index做清零。我们这样做有什么好处呢？这是因为也许可以减少“减一”操作的次数。假设当前时刻的元素如果做清零的话效果是-5，而resets里面有一个元素做清零其效果是-3，那么显然我们需要将resets里面做清零的元素拿出来留给当前元素。这叫做“反悔贪心”。

最终从后往前走完一遍之后，我们就知道哪些元素是真正需要被实施“清零”的。刨去这些之外，最后的n个时刻显然就是做“标记”操作的。这个安排保证了所有被清零的元素都能够得到“标记”。剩下的时刻就是应该做“减一”操作：我们必须要求所有“减一”操作的效果，加上“清零”操作的效果，最终一定是要大于nums里元素的总和。满足这些之后，才能判定目标在时间t内可行。
