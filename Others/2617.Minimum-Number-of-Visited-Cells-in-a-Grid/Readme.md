### 2617.Minimum-Number-of-Visited-Cells-in-a-Grid

按照正常的DP思路，我们令dp[i][j]表示到达(i,j)的最短时间。当更新dp[i][j]的时候，我们发现它的前驱状态会有很多，包括同行里左边的若干格子（不一定相连），同列上面的若干格子（不一定相连）。我们发现遍历这些前驱状态最多需要花费o(m)和o(n)的时间，再配上遍历全体的o(mn)，时间复杂度是超的。

我们换个DP的角度，如果已知dp[i][j]，那么我们可以更新未来的一些状态，包括同行右边的若干格子（一定相连），以及同列下边的若干格子（一定相连）。但是同理，这也是`o(m)*o(mn)`的时间复杂度。但是我们发现从这个角度考虑的话，你可以更新的格子是一个连续的subarray。举个例子，如果dp[i][j]=4，grid[i][j]=3，那么意味着(i,j+1)到(i,j+3)这三个格子的dp都可以更新到5，此外(i+1,j)到(i+3,j)这三个格子的dp也都可以更新到5. 我们立马就想到了差分数组的性质，可以避免将整个区间的元素逐个更新，只需要对这个连续区间的首尾进行标记即可。

具体的步骤是：我们首先给每一行和每一列配一个“差分点”的优先队列。按照上面的例子，假设我们得到`dp[i][j]=4`，且`grid[i][j]=step`, 那么意味着优先队列row_diff[i]里需要添加两个差分点，分别是`{j+1, 5}`和`{j+step+1, -5}`，表示第i行从第j列开始的格子，dp值可以是5，但是从第i行第j+step+1列开始的格子，dp值不能再有5. 同理，我们对于另一个优先队列col_diff[j]也添加类似的差分点，分别是`{i+1, 5}`和`{i+step+1, -5}`.

以上讲的是已知dp[i][j]，如何更新row_diff[i]与col_diff[j]。那么我们如何计算dp[i][j]呢？我们同样需要给每一行和每一列配一个multiset，表示当前可以选取的dp值，但是显然我们只会挑最小的。举个例子，当我们遍历到(i,j)点时，有序集合row[i]会从row_diff[i]里看是否在(i,j)有差分点，有的话就从row[i]里加入或者减去相应的dp值。同理，另一个有序集合col[j]会从col_diff[j]里看是否在(i,j)有差分点，有的话就从col[j]里加入或者减去相应的dp值。最终dp[i][j]必然是在row[i]和col[j]里里面挑最小的元素（即在一堆可选的dp值里挑最小的）。

综上，我们对每个(i,j)，先从从row_diff[i]和col_diff[j]读入差分点，更新row[i]和col[j]，然后选最小值得到dp[i][j]，然后往row_diff[i]和col_diff[j]再加入后续的差分点。

最终的答案就是dp[m-1][n-1].

类型的思路可以借鉴2158，2218，253。
