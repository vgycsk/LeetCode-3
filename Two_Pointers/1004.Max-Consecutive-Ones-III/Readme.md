### 1004.Max-Consecutive-Ones-III

#### 解法1：DP
令dp[i][k]表示截止到第i个元素位置，我们行使了k次翻转权利的话，最长的连续1区间的长度。突破口就是第i个元素我们是否进行翻转：
1. 如果A[i]==1，那么我们不需要翻转，即dp[i][k] = dp[i-1][k]+1
2. 如果A[i]==0，那么我们需要翻转，即dp[i][k] = dp[i-1][k-1]+1，注意k不能超过题目规定的行使反转权利的上限K。
答案就是dp[x][K]中的最大值。

以上方法的两层循环的时间复杂度是o(NK)，显然会超时。

#### 解法2：双指针
对于任何求subarray的问题，我们通常的做法就是固定左边界，探索右边界。假设我们固定左边界是`i`，那么要使右边界`j`最远，需要满足[i,j]最多有K个0。我们只需要将`j`单调右移，同时记录中间遇到了几个0即可。

综上，我们用for循环遍历左边界`i`：对于每个`i`我们记录移动右指针`j`，将`j`停在count为K的最远位置。然后左移一个`i`并更新count（如果A[i]原本是0的话，我们要吐出一个flip的名额），再接着移动`j`的位置。

所以两个指针都只会朝一个方向移动。这是快慢类型的双指针，时间复杂度就是o(N).
