### 2863.Maximum-Length-of-Semi-Decreasing-Subarrays

此题和 `962.Maximum-Width-Ramp` 一模一样。

#### 解法1
我们维护一个递增的“数组”arr，这是为了方便二分。对于新元素nums[i]，我们用二分法在arr里找到第一个大于nums[i]的元素nums[j]，于是对于i而言，它的最大跨度就是`i-j+1`.

如果nums[i]大于数组的尾元素，就加入arr。反之，那么我们就再不用考虑i，这是因为它“又小又晚”，不会为后续的元素带来更大的跨度。

#### 解法2
我们先构造一个单调递增的栈，注意我们从不退栈。方法如下：
```cpp
for (int i=0; i<n; i++)
{
    if (stk.empty() || nums[i]>nums[stk.top()])
        stk.push(i);            
}
```
这样的做法是我们希望尽量收录更早且更高的元素。任何更晚出现的、更小的元素，都不可能成为最优配对(i,j)中的i。

然后我们从后往前遍历nums[i]，我们持续退栈直至找到恰好比nums[i]大的元素j。退掉的元素不可惜，因为如果j与i是一个合法配对，那么任何大于j的元素都不会与小于i的元素组成更好的配对。
