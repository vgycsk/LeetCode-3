### 3093.Longest-Common-Suffix-Queries

在一堆字符串里面高效地寻找一个字符串（或它的前缀/后缀），显然我们会使用字典树的数据结构。

本题里面，我们在字典树里游走时，对于所处的节点，它可能被多个wordsContainer里面的字符串共享。那么对于每个节点，它究竟属于哪个字符串呢？根据题意，我们的选择依据是：先看总长度更小、再看出现的序号更小。因此，我们需要依据这个规则，给每个节点标记idx这个属性。所以对wordsQuery的某个后缀在字典树里游走完之后，它停留的节点的idx就是答案。

如果高效地给字典树的每个节点赋值idx呢？其实很简单，我们先将总长度更大的字符串加入字典树，再将总长度更小的字符串加入字典树。每次加入字符串时，idx的值就按加入字符串的index来。这样我们就发现，字符串长度小的自动会override每个节点的idx属性。同理，我们将wordsContainer序号更大的字符串先加入字典树，再将序号更小的字符串后加入字典树，这样每个节点的idx就会更新为相对更小的wordsContainer index。

综上，我们只需要将wordsContainer排序，按照“先看总长度更小、再看出现的序号更小”的原则排序，然后反序，按照后缀加入字典树。然后将wordsQuery的每个字符串按后缀在字典树里游走，最终停留在哪个节点，该节点的idx属性就是答案。
