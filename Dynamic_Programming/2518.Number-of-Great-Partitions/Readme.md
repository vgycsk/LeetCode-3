### 2518.Number-of-Great-Partitions

首先我们计算一下nums的总和，如果小于2k，那么直接返回无解。

从数据规模上来看，我们会写出类似于dp[i][s]的表达式，表示前i个元素里有多少种方案可以构造一组元素（称之为group A）其和是s。注意，我们无法穷举所有s的可能（否则上限会达到`1e9*1000`），但是本题里，因为元素和大于等于k对于我们来说没有区别，我们只需要计算`s<k`的dp值，而对应`s>=k`的dp值就是方案总数`2^i`（每个元素随机分入A或者B）所对应的补集。

那么如何计算dp[i][s]呢？这就是一个传统的背包问题。dp写法就是考虑是否选取第i个元素，如果选取则有`dp[i][s] = dp[i-1][s-nums[i]]`，如果不选取则有`dp[i][s] = dp[i-1][s]`，我们将这两种情况相加就是构造dp[i][s]的总的方案数。

于是，我们得到了`2^n - sum{dp[n][s], s=0,1,2,..k-1}`，表示构造group A元素和大于等于k的方案数。但是如何保证group B的元素和也大于等于k呢？我们就需要从中减去那些“group A元素和大等于k，且group B元素和小于k”的方案数。注意到，如果group A元素和大于等于k，言下之意必然有group B元素和小于k，这是我们在题目开头就保证的。所以“group A元素和大等于k，且group B元素和小于k”的方案数 => “group B元素和小于k”的方案数 => “group A元素和小于k”的方案数 => `sum{dp[n][s], s=0,1,2,..k-1}`

所以最终答案就是`2^n - 2 * sum{dp[n][s], s=0,1,2,..k-1}`
