### 2896.Apply-Operations-to-Make-Two-Strings-Equal

注意到，如果从i开始的、连续操作k次相邻元素的flip（每次代价为1），本质上就是将i和i+k距离k的两个元素flip，其他元素保持不变，代价就是k。

所以，我们直接将s1和s2里面元素不同的index拿出来放在nums数组里。于是任务就是：每次在nums里挑两个（未访问过的）元素i与j，代价是nums[j]-nums[i]，或者x。问最少花多少代价能将nums全部访问。当然，nums的元素个数必须是偶数，否则无解。

我们特别注意到，对于第一种操作，只会发生在nums里的两个相邻元素之间。为什么呢？假设有4个元素`p,...,k,j,i`，其中`k,j,i`是相邻的。如果我们将k与i按照第一种操作配对，代价是nums[i]-nums[k]；而将j与[k,i]之外的某个p配对，代价是c(p,j)。我们发现，`nums[i]-nums[k] >= nums[i]-nums[j]`，且`cost(p,j) >= cost(p,k)`，所以有`nums[i]-nums[k]+cost(p,j) >= nums[i]-nums[j]+ cost(p,k)`，也就是说不如将“i与j配对，k与p配对”来的更优。

接下来思考整个问题。首先要明确并没有任何贪心的方法。每次如何挑选两个元素，并没有特定的规律，最优解会随着数据的不同有各种不同的表现。我们只能用DP或者搜索的方式来解。

### 解法1:o(n^3)
最容易想到的是一个o(N^3)的区间DP。我们想得到区间的最优解dp[i][j]，只有两种拆解的方式：
1. 遍历一个中间的分界点k，我们先将[i:k]处理完，再将[k+1:j]处理完，那么dp[i][j]就是这两部分最优代价的和。
2. 最后一个访问的pair是(i,j)，所以dp[i][j] = dp[i+1][j-1] + cost(i,j).

最终取最优的解作为dp[i][j]. 大致的代价如下
```cpp
for (int d = 1; d<=n; d++) {
    for (int i=0; i+d-1<n; i++) {
        int j = i+d-1;
        dp[i][j] = dp[i+1][j-1] + cost(i,j);
        for (int k=i+1; k+1<j; k++) {
            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]);
        }
    }
}
return dp[0][n-1];
```

### 解法2:o(n^2)
对于每个元素nums[i]，它被访问的配对无非这么几种情况：
1. 与前一个相邻的元素配对，代价是nums[i]-nums[i-1]。前面已经证明过使用操作1的话，只能是与相邻元素配对。
2. 与之前某一个未配对的元素配对，代价是x，但是这个x算在了之前的那个元素上。
3. 与之后某一个未配对的元素配对，代价是x，并算在nums[i]上。

于是我们设计dp[i][j]表示：前i个元素里，我们留了j个操作未配对元素（但是已经计入了代价x），此时的最小总代价。分别对应三种策略是：
1. dp[i][j] = dp[i-2][j] + (nums[i]-nums[i-1]);
2. dp[i][j] = dp[i-1][j+1];
3. dp[i][j] = dp[i-1][j-1] + x;

三种策略里取最优的dp[i][j]。两层循环结束后，最终返回的是dp[n-1][0].

### 解法3:o(n)
上面的解法里第一层循环是o(N),第二层循环也是o(N).但事实上，关于“未配对元素”的个数，我们只需要考虑0或者1即可。

考虑nums序列如```k O O O j O O i```，其中k与j表示两个未配对的元素。如果尝试i与j配对，那么k只能与i之后的某个元素x配对。这个方案肯定不如“k与j配对、i与x配对”。同理，尝试i与k配对，那么j只能与i之后的某个元素x配对。这个方案也肯定不如“k与j配对、i与x配对”。所以在序列的遍历过程中，存留有两个或者两个以上未配对的方案肯定不是最优的。所以dp[i][j]的第二个下标只需要考察0和1即可。

