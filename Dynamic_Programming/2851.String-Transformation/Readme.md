### 2851.String-Transformation

首先，本题中的操作相当于切牌。无论一次切最后k张牌，都等效于切k次最后一张牌。最终得到的序列依然是原序列的shift而已。我们记s(i)表示以将字符串s调整后、变成以原来第i个元素为首的一个shift、

显然，只有对应部分的i，可以使得`s(i)=t`。我们可以先用KMP算法，算出t在`s+s`中能匹配几次。我们就可以记录有p种shift使得`s(i)=t`，其中`p<=n`.

对于每次操作，我们有n-1次选择（对应不同的shift），那么经过k次操作之后，s(i)的分布是什么呢？我们特别关心上述的p种shift，因为它们对应着我们想要的答案。

我们令f[j]表示经过j次操作后不是想要的shift（我们称为未匹配）的操作数目（也就是字串数目），令g[j]表示经过j次操作后恰是想要的shift（称为匹配）的操作数（也就是字串数目）。我们有动态转移方程：
```
f[j] = (n-p-1)*f[j-1] + (n-p)*g[j-1]
g[j] = p*f[j-1] + (p-1)*g[j-1]
```
第一行的解释：对于j-1轮不匹配的字串，下一轮有n-p-1种操作依然得到不匹配的字串（因为不能shift成自己）。对于j-1轮已经匹配的字串，下一轮有n-p种操作变成不匹配的字串。同理第二行的解释：对于j-1轮不匹配的字串，下一轮有p种操作变成匹配的字串。对于j-1轮已经匹配的字串，下一轮有p-1种操作依然变成匹配的字串（因为不能shift成自己）。

所以我们有状态转移 (f,g)'(j)  = T * (f,g)'(j-1)，其中转移矩阵
```
T = [n-p-1, n-p
     p,    p-1 ]
```
所以第k轮操作之后，(f,g)'(k)  = T^k * (f,g)'(0). 注意，T^k依然是一个2x2的矩阵。

其中如果初始时s==t，那么(f,g)(0) = {0, 1}，否则 (f,g)(0) = {1, 0}。 另外`T^k`可以用快速幂的思想，用log(k)的时间计算。最后记得再与初始状态`(f,g)'(0)`相乘。

由此我们计算出 (f,g)(k)，得到第k轮时变成未匹配字串的数目，以及变成匹配字串的数目（答案）。

