### 2572.Count-the-Number-of-Square-Free-Subsets

数组的元素有n个，每个元素都有选或不选两种策略，故subset的种类就是`2^n`。本题的要求是寻找某些subset，使得他们的乘积里每个质因数最多只能出现一次。根据数值的范围（小于30），我们发现质因数的种类只有10种，即`2,3,5,7,11,13,17,19,23,29`. 所以我们可以用一个10 bit的二进制数state来表示哪些质因数已经被选了，那么对于任意nums[i]是否能选，其实就是取决于state。所以我们可以知道本题是一个动态规划，状态变量是dp[i][state]。我们试图从dp[i-1]来推出dp[i]。

如果我们不想选nums[i]，那么有`dp[i][state] += dp[i-1][state]`。如果我们想选nums[i]，那么有个前提条件，即state里必须包含nums[i]的所有质因数（且每个质因数必须只出现一次）。我们也可以用一个二进制数s来表示nums[i]所包含的质因数状态，那么有`dp[i][state] += dp[i-1][state-s]`. 特别注意，如果`nums[i]=1`，那么是否选取对state都没有影响，故`dp[i][state]=dp[i-1][state]*2`.

最终`sum(dp[n][state])`就是满足所有质因数最多只出现一次的subset的数目。注意要减一排除空集。
