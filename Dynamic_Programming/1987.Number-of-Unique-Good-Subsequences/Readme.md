### 1987.Number-of-Unique-Good-Subsequences

#### 解法1 (deprecated)
此题和```LC940.Distinct-Subsequences-II```的联系非常紧密。我们可以先用LC940的方法计算所有distinct subsequence的总数。令dp[i]表示前i个字符的前缀里有多少个不同的子序列（包括有先导零的子序列以及空子序列）。核心代码如下：
```cpp
for (int i=1; i<=n; i++)
{
  int j = s[i]=='0' ? last0[i] : last1[i];
  dp[i] = dp[i-1]*2 - dp[j-1];
}
```
那么接下来如何转变为题目要求的“无先导零”的子序列呢？我们发现上述式子里的dp[i]都依赖于dp[i-1]，所以我们只要控制初始的dp值即可。假设binary的开头有m个零，那么显然dp[1]到dp[m]都应该是0，因为它们无法拼凑出任何合法的子序列。而dp[m+1]应该是1，因为它只能构造“1”这一个合法的子序列。此后对于i>m+1，利用上述的代码能够得到所有正确的dp[i]。

这里给个直观的解释。首先，从i=m+1开始```+ dp[i-1]*2```这部分，意思是在前面已有的合法子序列的基础上，append s[i] or not，因此所对应的一定都是已经以1开头的子序列。其次```-dp[j-1]```这部分，去重的是形如```x x x s[i]```这样的字符串，其中```x x x```是前j-1个字符所能构建的distinct subsequence. 如果j-1<=m，那么这些dp[j-1]都预置为0，所以去重的部分也不会包括以0开头的子序列。综上所述，每一步所计算的dp[i]都表达的是以1开头的子序列。

#### 解法2 (preferred)
此题有非常简洁的DP解法。令zero表示截止目前以0结尾的unique子序列的数目，令one表示截止目前以1结尾的unique子序列的数目。那么
```cpp
if (s[i]=='0')
  zero = one + zero;
else
  one = one + zero + 1;
```
这段代码需要特别的解读。从字面上看，第一个分支里`zero = one + zero`语句更新后的zero，应该指以s[i]为结尾的、unqiue的子序列。但是注意到我们定义的zero，只是“以0结尾的、unique子序列的数目”，并没有要求一定要以s[i]结尾呀。这有问题吗？其实这就是精华所在。在前缀s[0:i]里，“以0结尾的、unique子序列的数目”必然等于“以s[i]结尾的、unique子序列的数目”。因为前者的任何一个序列，我们都可以把最后一个0的位置认为是放在s[i]。反之，后者的任何一个序列，也必然是以0结尾的。

同理，我们可以解释第二个分支。其中“+1”是因为s[i]可以自己单独作为序列，但是0不行（它会给后面子序列的生成产生先导零）。

最终的答案是`one+zero`。如果s里存在任何一个0的话，那么再加1.
