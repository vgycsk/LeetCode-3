### 2366.Minimum-Replacements-to-Sort-the-Array

#### 解法1

我们从后往前看，对于最后一个数，我们肯定不会拆分。一旦将其拆分的话变小的话，那么前面的数就有更大的概率需要拆得更小。

接着假设最后一个数是x，倒数第二个数是y。如果y小于等于x，那么最后两个元素已经是递增关系，y就不用拆分了，理由同上。如果y大于x，那么就必须拆分y，那么怎么拆分呢？

根据规则，我们想要尽量少地拆分，又不能拆出大于x的数（否则破坏递增），不难通过贪心的思想，知道我们需要尽量拆出完整的x来。假设y除以x的商是k，余数是d，那么我们有一个初始方案：就是拆成一个d，加上k个x。这一定保证了拆分的数目最少。但是d太小的话，会影响左侧元素迫使他们拆分地更细。所以我们试图在不改变这k+1拆份的前提下，尽量地抬升d。怎么抬升呢？显然是由这k个x来提供帮助。如果这k个x集体减少一，那么d就能抬升k。为什么这k个x需要集体行动呢？因为人多力量大啊，让某些x不出力的话留着也没有啥用，不如提供给d来加速d的抬升。

那么我们将d抬升多少呢？注意提升后的d不能比下降后的x高。因为我们想抬升d是因为d是当前y拆分出来的最小值，是制约前面元素拆分的“瓶颈”。所以最理想的情况是将y恰好拆分成均匀的k份。如果不行，那么我们就将d抬升至小于等于降低后的x。令所有的x降低p，则有比等式
```
d + p*k <= x - p
```
这样得到
```
p <= (x-d) / (k+1)
```
意思是p不能再大了，再大的话d要反超x了。

这样操作之后，原本的1个d和k个x，变成了1个d2和k个x2，其中`d2 = d + p`，`x2 = x - p`，且`d2 <= x2`. 

此时这是不是最优的操作呢？并不是。如果`d2 < x2`，其实我们可以将k个x2里面的一部分（而不是整体）拿出1来再贡献给d2，必然可以使得d2再拉至于x2-1平齐的高度。这是因为之前我们知道，如果k个x2每人都再贡献1出来，会导致`d2`会比`x2-1`还大。所以这意味着，如果贡献出部分的1出来，就能让`d2`与`x2-1`持平。在这种情况下，`x2-1`就是拆分出来的k+1份里的最小值。

于是，这个回合结束我们将nums[i]赋值为`x2`（如果`d2==x2`）或者`x2-1`（如果`d2<x2`）。下一个回合就是针对nums[i]，来策划对于nums[i-1]的拆分。完全重复上述的过程。

#### 解法2
还有一种写起来更简单的解法。我们已经知道，我们试图将y做最少的拆分，且每一份不能拆过x。显然，我们拆分的份数就是`k = ⌈y/x⌉`，其中`⌈.⌉`表示一个分数的上整界。如果你还知道一个结论（或者直觉）：将一个数y拆成k份，一定可以表示成若干个`⌈y/k⌉`与若干个`⌊y/k⌋`之和，那么显然这就是最为平均的一种分法（因为任何元素之间彼此不超过1）。根据解法1的分析，我们会把nums[i]重置为这种分法得到的最大的最小值值`⌊y/k⌋`。
