### 2370.Longest-Ideal-Subsequence

#### 解法1
令dp[i]表示以i为结尾的最长subsequence的长度。我们需要寻找这个subsequence的上一个位置j，这样就有`dp[i]=dp[j]+1`。那么j可以是在哪里呢？根据题意，j所在的字母必须是与s[i]的ASCII差距在k以内的字母。在知道是哪些字母后，于是我们需要维护一个长度为26的数组`prev[ch]`，表示当前位置i之前最近的字母ch出现在哪个位置。

举个例子，如果当前s[i]='b'，且k=1。那么我们就需要查看这两处位置`j1 = prev['a']`和`j2 = prev['c]`，这样就可以有`dp[i] = max(dp[j1], dp[j2]) + 1`. 特别注意，对于任意的dp[i]都有一个基本解是`dp[i] = 1`.

最终的答案是返回在全局`dp[i]`中最大的一个。

#### 解法2
令dp[ch]表示以字母ch为结尾的最长子序列的长度。那么对于s[i]而言，假设其字母是c，我们可以知道如果以s[i]为结尾的子序列，其倒数第二个字母的取值范围[x:y]，于是dp[c]就可以更新为dp[x]到dp[y]中的最大值加一。
