### 2663.Lexicographically-Smallest-Beautiful-String

本题的关键就是如何解读“不能出现回文子串”。其实这个约束可以简化为“没有任何两个相邻的字符相同”，且“没有任何长度为3的子串里第一个和第三个字符相同”。

然后我们就可以贪心地从低位往高位遍历，查看某位置i上能否填写一个比原先更大的字符，且满足上述的约束。如果可以，那么我们必然会尝试贪心地将[i+1:n-1]这一段构造为字典序最小、且符合约束的字符串。事实上，我们总是能构造成功的，因为在任何的位置上，我们只有两个约束（不能与前一个字符相同，不能与前前字符相同），但是`k>=4`，我们至少可以有四种候选。故这样的贪心构造法必然能实现，且保证字典序最小。

因此，只要我们从低位往高位遍历，找到第一个实现上述构造（即s[i]和s[i+1:n-1]都满足条件）的位置，那么就有了最终答案。
