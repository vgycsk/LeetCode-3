### 2612.Minimum-Reverse-Operations

此题类似于jump game，从起点开始，根据滑窗的不同位置，可以将1移动到多个不同的地方。然后下一轮，再根据滑窗的不同位置，可以将1继续移动到不同的地方。依次类推，可以用BFS求出1到达各个位置所用的最短步数（也就是用了几轮BFS）。

我们假设1的初始位置是i，滑窗的左右边界是L和R（且`R-L+1=k`），那么1就可以通过翻转从i到新位置`j = L+R-i = 2*L-i-1`，这是一个仅关于L的函数。考虑滑窗长度固定，且必须包含位置i，所以L的最左边可以到达`i-k+1`，最右边可以到达`i`。此外，L不能越界，即必须在[0,n-1]内，所以L的左边界其实是`L0=max(0,i-k+1)`，右边界其实是`min(i,n-1)`. 于是对应的j的移动范围就是`2*L0-i-1`到`2*L1-i-1`之间，并且随着L从小到大移动，j的变动始终是+2.

我们在尝试进行BFS的时候，最大的问题就是，我们通过i进行一次revert得到的j会有很多位置（因为滑窗可以运动），其中很多j可能是之前已经遍历过的（也就是已经确定了一个更少的步数就可以到达），我们需要挨个检验的话时间复杂度就会很高。本题有巧解。对于一次revert，j的候选点的编号要么都是同奇数（要么都是偶数），并且在奇数（或者偶数）意义上是连续的！所以我们事先将所有编号是奇数的点作为一个集合odd，将所有编号是偶数的点作为一个集合even，那么这次revert相当于在odd（或者even）上删除一段区间range（删除意味着遍历过）。只要集合是有序的，那么我们就可以很快定位到range在集合里的位置，将range在集合里面的元素都删除。因为每个元素只会在集合里最多被删除一次（以后的range定位都不会涉及已经删除的元素），所以我们可以用近乎线性的时间知道每个元素是在什么时候从集合里删除的，这就是可以到达的最小步数。

对于banned里面的元素，只需要实现从odd和even里排除即可。
